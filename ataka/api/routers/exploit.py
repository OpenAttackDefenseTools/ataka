import base64
import binascii
import os
import re
import secrets
from datetime import datetime

from fastapi import APIRouter, Depends, HTTPException
from pydantic import BaseModel
from sqlalchemy import select
from sqlalchemy.exc import IntegrityError, NoResultFound
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import selectinload

from ataka.api.dependencies import get_session, get_channel
from ataka.common.database.models import ExploitHistory, Exploit, Job, Execution

router = APIRouter(prefix="/exploit", tags=['exploit'])

@router.get("/")
async def exploit_all(session: AsyncSession = Depends(get_session)):
    get_exploits = select(Exploit)
    exploits = (await session.execute(get_exploits)).scalars()
    return [x.to_dict() for x in exploits]


class ExploitCreateRequest(BaseModel):
    history_id: str
    author: str
    context: str


@router.post("/")
async def exploit_create(req: ExploitCreateRequest,
                         session: AsyncSession = Depends(get_session),
                         channel=Depends(get_channel)):
    try:
        context = base64.b64decode(req.context)
    except binascii.Error:
        raise HTTPException(400, detail="Invalid Docker context encoding")

    get_history = select(ExploitHistory) \
        .where(ExploitHistory.id == req.history_id) \
        .options(selectinload(ExploitHistory.exploits),
                 selectinload(ExploitHistory.exclusions))
    try:
        history = (await session.execute(get_history)).scalar_one()
    except NoResultFound:
        raise HTTPException(404, detail="History does not exists")

    max_idx = 0
    prefix = req.history_id + '-'
    for exploit in history.exploits:
        if exploit.id.startswith(prefix):
            try:
                idx = int(exploit.id[len(prefix):])
            except ValueError:
                continue
            max_idx = max(max_idx, idx)
    exploit_id = f'{prefix}{max_idx + 1}'
    docker_name = re.sub(r'[^0-9a-z\-]+', '', exploit_id.lower()) + "-" + secrets.token_hex(8)

    ctx_path = f"/data/exploits/{docker_name}"
    excl_opener = lambda path, flags: os.open(path, flags | os.O_EXCL)
    try:
        with open(ctx_path, "wb", opener=excl_opener) as f:
            f.write(context)
    except FileExistsError:
        raise HTTPException(500, detail="Exploit already exists (file)")

    exploit = Exploit(id=exploit_id, exploit_history_id=req.history_id, docker_name=docker_name,
                      active=False, author=req.author)
    session.add(exploit)
    try:
        await session.commit()
    except IntegrityError:
        raise HTTPException(500, detail="Exploit already exists (db)")

    return exploit.to_dict() | {"history": history.to_dict()}


class ExploitPatchRequest(BaseModel):
    active: bool


@router.patch("/{exploit_id}")
async def exploit_patch(exploit_id: str, req: ExploitPatchRequest,
                        session: AsyncSession = Depends(get_session)):
    get_exploit = select(Exploit).where(Exploit.id == exploit_id)
    try:
        exploit = (await session.execute(get_exploit)).scalar_one()
    except NoResultFound:
        raise HTTPException(404, detail="Exploit does not exists")

    exploit.active = req.active
    await session.commit()

    return {}


@router.get("/{exploit_id}/jobs")
async def exploit_jobs(exploit_id: str, limit: int = 10, after: int = 0,
                       session: AsyncSession = Depends(get_session)):
    get_jobs = select(Job) \
        .where((Job.exploit_id == exploit_id) & (Job.timestamp >= datetime.fromtimestamp(after))) \
        .order_by(Job.timestamp.desc()) \
        .limit(limit) \
        .options(
        selectinload(Job.executions).selectinload(Execution.target))
    jobs = (await session.execute(get_jobs)).scalars()

    return [
        {
            "job": job.to_dict(),
            "executions": [x.to_dict() | {"target": x.target.to_dict()} for x in job.executions],
        }
        for job in jobs
    ]


@router.get("/{exploit_id}/download")
async def exploit_download(exploit_id: str,
                           session: AsyncSession = Depends(get_session)):
    get_exploit = select(Exploit).where(Exploit.id == exploit_id)
    try:
        exploit = (await session.execute(get_exploit)).scalar_one()
    except NoResultFound:
        raise HTTPException(404, detail="Exploit does not exists")

    ctx_path = f"/data/exploits/{exploit.docker_name}"
    with open(ctx_path, "rb") as f:
        data = f.read()

    return {"data": base64.b64encode(data).decode()}
