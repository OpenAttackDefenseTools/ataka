from typing import Set

from fastapi import APIRouter, Depends, HTTPException
from pydantic import BaseModel
from sqlalchemy import select
from sqlalchemy.exc import IntegrityError, NoResultFound
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import selectinload, joinedload

from ataka.api.dependencies import get_session
from ataka.common.database.models import ExploitHistory, Exclusion

router = APIRouter(prefix="/exploit_history", tags=['exploit_history'])


@router.get("/")
async def exploit_history_list(session: AsyncSession = Depends(get_session)):
    get_histories = select(ExploitHistory).options(joinedload(ExploitHistory.exploits))

    histories = (await session.execute(get_histories)).unique().scalars()
    return [history.to_dict() | {"exploits": [exploit.to_dict() for exploit in history.exploits]} for history in
            histories]


class ExploitHistoryCreateRequest(BaseModel):
    history_id: str
    service: str


@router.post("/")
async def exploit_history_create(req: ExploitHistoryCreateRequest, session: AsyncSession = Depends(get_session)):
    history = ExploitHistory(id=req.history_id, service=req.service)
    session.add(history)
    try:
        await session.commit()
    except IntegrityError:
        raise HTTPException(400, detail="History already exists")

    return {}


@router.get("/{history_id}")
async def exploit_history_get(history_id: str, session: AsyncSession = Depends(get_session)):
    get_history = select(ExploitHistory) \
        .where(ExploitHistory.id == history_id) \
        .options(joinedload(ExploitHistory.exploits))
    try:
        history = (await session.execute(get_history)).unique().scalar_one()
    except NoResultFound:
        raise HTTPException(404, detail="History does not exists")

    return history.to_dict() | {"exploits": [exploit.to_dict() for exploit in history.exploits]}


@router.get("/{history_id}/exclusions")
async def exploit_history_get_exclusions(
        history_id: str,
        session: AsyncSession = Depends(get_session)
):
    get_history = select(ExploitHistory) \
        .where(ExploitHistory.id == history_id) \
        .options(selectinload(ExploitHistory.exclusions))
    try:
        history = (await session.execute(get_history)).scalar_one()
    except NoResultFound:
        raise HTTPException(404, detail="History does not exists")

    return [x.target_ip for x in history.exclusions]


class ExclusionsPutRequest(BaseModel):
    target_ips: Set[str]


@router.put("/{history_id}/exclusions")
async def exploit_history_put_exclusions(
        history_id: str,
        req: ExclusionsPutRequest,
        session: AsyncSession = Depends(get_session)
):
    get_history = select(ExploitHistory) \
        .where(ExploitHistory.id == history_id) \
        .options(selectinload(ExploitHistory.exclusions))
    try:
        history = (await session.execute(get_history)).scalar_one()
    except NoResultFound:
        raise HTTPException(404, detail="History does not exists")

    cur_ips = set(x.target_ip for x in history.exclusions)

    # try:
    for ip in req.target_ips:
        if ip not in cur_ips:
            excl = Exclusion(exploit_history_id=history_id, target_ip=ip)
            session.add(excl)
    for excl in history.exclusions:
        if excl.target_ip not in req.target_ips:
            await session.delete(excl)

    await session.commit()

    return {}
