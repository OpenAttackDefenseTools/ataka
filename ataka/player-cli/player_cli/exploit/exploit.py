from enum import Enum
import time

import typer
from rich import print

from player_cli.ctfconfig_wrapper import START_TIME, ROUND_TIME

from player_cli.util import request, dt_from_iso, ERROR_STR, WARN_STR, dt_to_local_str, greenify

ACTIVE_STR = greenify('ACTIVE')


def get_all_histories():
    histories = request('GET', 'exploit_history/')

    for history in histories:
        for exploit in history['exploits']:
            exploit['timestamp'] = dt_from_iso(exploit['timestamp'])
            exploit['history'] = history
        history['exploits'].sort(key=lambda x: x['timestamp'])

    return histories


class ResolveStrategy(Enum):
    LATEST = 0
    ACTIVE = 1


def resolve_exploit(exploit_or_history_id: list[str] | str,
                    resolve_strategy: ResolveStrategy = ResolveStrategy.LATEST) -> list[dict] | dict:
    histories = get_all_histories()

    def _resolve(exploit_id):
        for history in histories:
            if exploit_id == history['id']:
                suitable_exploits = history['exploits'] if resolve_strategy == ResolveStrategy.LATEST else \
                    [exploit for exploit in history['exploits'] if exploit['active']]

                if len(suitable_exploits) == 0:
                    print(f'{ERROR_STR}: no'
                               f'{" " if resolve_strategy == ResolveStrategy.LATEST else " active "}'
                               f'exploits in history "{history["id"]}"')
                    raise typer.Exit(code=1)

                return suitable_exploits[-1]

            for exploit in history['exploits']:
                if exploit['id'] == exploit_id:
                    return exploit

        print(f'{ERROR_STR}: unknown exploit or history "{exploit_id}"')
        raise typer.Exit(code=1)

    if type(exploit_or_history_id) == str:
        return _resolve(exploit_or_history_id)
    else:
        # Deduplicate
        exploit_set = {exploit['id']: exploit for exploit in
                       [_resolve(exploit_id) for exploit_id in exploit_or_history_id]}
        return list(exploit_set.values())


def resolve_history(exploit_or_history_id: list[str] | str):
    histories = get_all_histories()

    def _resolve(exploit_id):
        for history in histories:
            if exploit_id == history['id']:
                return history

            for exploit in history['exploits']:
                if exploit['id'] == exploit_id:
                    return history

        print(f'{ERROR_STR}: unknown exploit or history "{exploit_id}"')
        raise typer.Exit(code=1)

    if type(exploit_or_history_id) == str:
        return _resolve(exploit_or_history_id)
    else:
        history_set = {history['id']: history for history in
                       [_resolve(exploit_id) for exploit_id in exploit_or_history_id]}
        return list(history_set.values())


def activate_exploit(exploit):
    history = exploit['history']
    if any(exploit['active'] for exploit in history['exploits']):
        print(f'{WARN_STR}: an exploit is already active, doing nothing')
        return

    print(f'Activate {exploit["id"]}')
    request('PATCH', f'exploit/{exploit["id"]}', data={
        'active': True
    })

    exploit['active'] = True


def deactivate_history(history):
    if not any(exploit['active'] for exploit in history['exploits']):
        print(f'{WARN_STR}: no exploit active, doing nothing')
        return

    for exploit in history['exploits']:
        if exploit['active']:
            print(f'Deactivate {exploit["id"]}')
            request('PATCH', f'exploit/{exploit["id"]}', data={
                'active': False
            })
            exploit['active'] = False


def print_history(history):
    from .target import print_exploit_targets

    print(f'{history["id"]} ({history["service"]})')

    has_active = False
    exploits = history['exploits']
    if not exploits:
        print('    No uploaded exploits yet')
    else:
        for exploit in exploits:
            if exploit['active']:
                has_active = True

            active = ACTIVE_STR if exploit['active'] else ''
            ts = dt_to_local_str(exploit['timestamp'])
            print(f'    {ts} {active:6} {exploit["author"]} {exploit["id"]}')

    if has_active:
        print('')
        print_exploit_targets(history, indent=4)

    print('')


def print_logs(exploits: list[dict], limit=1):
    from .execution import print_exploit_execution
    from ..flags import poll_and_show_flags

    print(f'Showing logs for exploits: {", ".join([exploit["id"] for exploit in exploits])}')
    print()

    start_of_tick = START_TIME + ROUND_TIME * (((time.time() - START_TIME) // ROUND_TIME) + 1 - limit)

    job_items = []
    for exploit in exploits:
        exploit_items = request('GET', f'exploit/{exploit["id"]}/jobs', params={
            'after': start_of_tick,
        })
        for item in exploit_items:
            item['job']['timestamp'] = dt_from_iso(item['job']['timestamp'])
        job_items += exploit_items

    job_items.sort(key=lambda x: x['job']['timestamp'])

    execution_ids = []

    for item in job_items:
        job = item['job']
        for execution in item['executions']:
            execution_ids.append(execution['id'])
            print_exploit_execution(job, execution)

    poll_and_show_flags(execution_ids)
